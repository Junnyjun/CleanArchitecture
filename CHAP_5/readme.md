 #### 4. 컴포넌트

---

**아키텍쳐**는 프로그래머이다 

시스템을 구축했던 사람들이 만들어낸 시스템의 형태이다

시스템의 생명주기를 지원하고 비용과 생산성의 효율성을 끌어올린다.

 - 배포

아키텍쳐는 시스템을 쉽게 배포할 수 있도록 배포전략을 고려해야 한다.

 - 운영

아키텍쳐는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상 시키고,

개발자에게 주요 목표로 인식되게 해야한다.

 - 유지보수

유지보수는 모든 측면에서 보았을때 비용이 가장 많이 든다.

 - 선택사항 열어두기

확장성을 고려해야한다. ( 세부사항 , 고도화 ) 

  데이터베이스 시스템을 고려하지 않아도 된다

  웹서버를 선택할 필요가 없다

  REST를 적용할 필요가 없다

  의존성 주입을 적용할 필요가 없다

> 독립성

- 유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다.

좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

- 운영

시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.

각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬어질 것이다.

- 개발

아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할을 수행한다.

콘웨이(Conway)의 법칙이 작용하는 지점이 바로 여기다. 콘웨이의 법칙은 다음과 같다.

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

많은 팀으로 구성된 상황에서 개발을 해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보해야 한다.

​      잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템 분할

- 배포

아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다.

좋은 아키텍처는 **즉각적인 배포(immediate deployment)**를 목표로 한다.

마스터(메인) 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리한다.

- 선택사항 열어놓기

좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다.

- 계층 결합 분리

아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 **다른 이유로 변경되는 것들을 분리**하고, **동일한 이유로 변경되는 것들을 묶는다.**

- 개발 독립성

컴포넌트가 완전히 분리되면 개발 팀도 분리된다. → 아키텍처는 팀 구조를 뒷받침 한다.

- 배포 독립성

유스케이스와 계층의 결합이 분리되면 배포 측면에서고 고도의 유연성이 생긴다.

실제로 결합을 제대로 분리했다면 운영 중인 시스템에서고 계층과 유스케이스를 교체(hot-swap) 할 수 있다.
  새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 새로운 `jar` 파일이나 서비스 몇 개를 추가하는 정도로 단순한 일이 된다.

-  중복

중복에는 **진짜 중복**과 **우발적 중복** 이 있다.

진짜 중복은 개발자라면 중복을 제거하거나 줄여야 한다.
우발적 중복은 진짜 중복이 아니다.(서로 다른 속도와 다른 이유로 변경된다면 중복이 아니다.)



-  결합 분리 모드(다시)

다시 결합 분리 모드로 돌아가보자.

계층과 유스케이스의 결합을 분리하는 방법은 다양하다. 소스 코드 수준에서 분리, 바이너리 코드(배포)수준에서, 그리고 실행 단위(서비스) 수준에서도 분리할 수 있다.

**소스 수준 분리 모드**: 소스 코드 모듈 사이의 의존성을 제어할 수 있다.

모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 때 간단한 함수 호출을 사용한다.

이러한 구조를 흔히 모노리틱 구조라고 부른다.



**배포 수준 분리 모드**: 배포 가능한 단위(라이브러리, `jar` 파일, DDL 등)들 사이의 의존성을 제어할 수 있다.

**서비스 수준 분리 모드**: 의존하는 수준을 데이터 구조 단위까지 낮출 수 있다.

순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.

완전히 독립적이다.(서비스, 마이크로 서비스)



좋은 아키텍처는 결합 분리 모드를 **선택사항**으로 남겨두어 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다.

좋은 아키텍처는 모노리틱 구조로 시작해 마이크로서비스 수준까지 성장해도 원래 형태로 돌아갈 수 있어햐 한다.

###### 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.




> 경계 선긋기

소프트웨어 아키텍처는 선을 긋는 기술이고, 저자는 이런 선을 경계(boundary)라고 부른다



관련이 있는 것과 없는 것 사이에 선을 긋는다.

- GUI는 업무 규칙과는 관련이 없다.
- 데이터베이스는 GUI와는 관려이 없다.
- 데이터베이스는 업무 규칙과 관련이 없다.



###### 입출력?

- GUI는 시스템이 아니다.
  - 눈으로 동작하는 모습을 볼 수 있어야 하는게 아니다. → 입력과 출력은 중요하지 않다.
- GUI와 BusinessRules 는 분리되어야 한다.




###### 플러그인 아키텍처

소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다.

데이터베이스를 쉽게 교체할 수 있는 건 아니다.

- 하지만 플러그인 구조를 가정한 채 시작함으로써, 최소한 우리는 변경 작업을 현실성 있도록 만들 수 있다.

###### 결론

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.

컴포넌트 사이의 화살표가 특정 방향(핵심 업무)을 향하도록 배치

의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것임을 눈치챌 수 있어야 한다.

- 의존성 화살표는 저수준 세부사항에서 고수준 추상화를 향하도록 배치 된다.



> 경계 해부학

시스템 아키텍쳐는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.



###### 경계 횡단하기

한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일.

- 적절한 위치에서 경계를 횡단하게 하는 비결은 **소스 코드 의존성 관리**에 있다.
  - 왜냐하면 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야 할지도 모르기 때문이다.
    → **경계**는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.

###### 두려운 단일체

가장 단순하고 흔한 경계는 물리적으로 엄격하게 구분되지 않는 형태이다.

- 소스 수준 분리 모드
- 배포 관점 → 단일체(monolith) .jar파일로 묶인 자바 클래스 파일, 링크된 C, C++ 프로젝트
  - 배포 관점에서 보면 단일체는 경계가 드러나지 않는다.
  - 그렇다고 해서 경계가 존재하지 않거나 무의미 하다는 뜻은 아니며, 그 안에 포함된 다양한 컴포넌트 개발을 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.

가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.

- 런타임 의존성과 컴파일타임 의존성은 모두 같은방향, 즉 **저수준 컴포넌트에서 고수준 컴포넌트로 향한다.**
- 만약 고수준 클라이언트에서 저수준 서비스를 호출해야 한다면 의존성 역전을 이용하면 된다.

###### 배포형 컴포넌트

- 아키텍처의 경계가 물리적으로 드러날 수 있는데 가장 단순한 형태는 동적 링크 라이브러리다.(npm, yarn workspace, Gem, jar 등)
- DLL(Dynamic Link Library)로 배포하면 따로 컴파일하지 않고 바로 사용할 수 있다.
- 컴포넌트는 바이너리와 같이 배포 가능한 형태로 전달된다.
  - 배포 수준 결합 분리 모드에 해당
- 배포 과정에서만 차이가 날 뿐, 배포 수준의 컴포넌트는 단일체와 동일한다.
- 일반적으로 모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 경계를 가로지르는 통신은 순전히 함수 호출과 같아 매우 값싸다.

###### 스레드

단일체와 배포형 컴포넌트는 모두 스레드를 활용할 수 있다.

- 스레드: 아키텍처 경계x, 배포 단위x, 실행 계획과 순서를 체계화하는 방법에 가까움

모든 스레드가 단 하나의 컴포넌트에 포함될 수 도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다.

###### 로컬 프로세스

훨씬 강한 물리적 형태를 띠는 아키텍처 경계로 로컬 프로세스가 있다.

- 명령행(terminal)이나 유사한 시스템 호출을 통해 생성된다.
- 로컬 프로세스는 컴포넌트 간 의존성을 동적 다형성을 통해 관리하는 저수준 컴포넌트로 구성된다.
- 소스 코드 의존성의 화살표는 항상 고수준 컴포넌트를 향한다.

###### 서비스

물리적인 형태를 띠는 **가장 강력한 경계**는 서비스이다.

- 서비스는 프로세스로, 명령행 또는 그와 동등한 시스템 호출을 통해 구동된다.
- 서비스는 자신의 물리적 위치에 구애받지 않는다.
- 서비스는 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다.
  - 이때 발생하는 지연(latency)에 따른 문제는 고수준에서 처리할 수 있어야 한다.
- 저수준 서비스는 고수준 서비스에 **'플러그인'**되어야 한다.
  - 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면, URI)도 절대 포함해서는 안 된다.

###### 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계전략을 사용한다.

실제로 서비스는 **상호작용하는 일련의 로컬 프로세스 퍼사드(Faacade)**에 불과할 때가 많다.

즉, 대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.



> 정책과 수준

###### 수준

'수준(level)'을 엄밀하게 정의하면 **'입력과 출력까지의 거리'**다.

- 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
- 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.

소스 코드 의존성은 그 수준에 따라 결합되어야 하며, **데이터 흐름을 기준으로 결합되서는 안 된다.**

- 데이터 흐름과 소스 코드 의존성이 항상 같은 방향을 가리키진 않음

다음은 잘못된 아키텍처가 적용된 암호화 프로그램을 작성했을때 예이다.

```
function encrypt() {
  while (true) {
    writeChar(translate(readChar()));
  }
}
```

- 고수준인 `encrypt` 함수가 저수준인 `readChar`와 `writeChart` 함수에 의존하기 때문에 잘못된 아키텍처이다.



###### 결론

정책에 대한 논의는 아래 원칙을 모두 포함한다.

- 단일 책임 원칙
- 개방 폐쇄 원칙
- 공통 폐쇄 원칙
- 의존성 역전 원칙
- 안정된 의존성 원칙
- 안정된 추상화 원칙

이 원칙들의 설명을 다시 읽어 보고 각 원칙이 어디에서 무슨 이유로 사용되었는지를 잘 숙지하자.



> 업무 규칙

###### 엔티티

- 컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화 한다.

다음 그림은 대출을 뜻하는 Loan 엔티티를 UML 클래스로 나타낸 것이다.

![그림 20.1 UML 클래스로 표현한 Loan 엔티티](https://uchanlee.dev/static/987832db5a9a384324373eb0079a1c52/0a47e/image-20.1.png)

그림 20.1 UML 클래스로 표현한 Loan 엔티티

- 세 가지의 핵심 업무 데이터를 포함
- 데이터와 관련된 세 가지 핵심 업무 규칙을 인터페이스로 제공함

엔티티를 만들때 유일한 요구조건은 핵심 업무 데이터와 핵심 업무 규칙을 하나로 묶어서 별도의 소프트웨어 모듈로 만들어야 한다는 것이다.

- 꼭 객체 지향 언어를 사용할 필요 없음

###### 유스케이스

모든 업무 규칙이 엔티티처럼 순수한 것은 아니다.

- 유스케이스는 자동화된 시스템이 사용되는 방법을 설명한다.
  - 수동 환경에서 사용 불가
- 유스케이스는 사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.
- 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된(application-specific) 업무 규칙을 설명한다.

다음은 유스케이스의 예제다.

![그림 20.2 유스케이스 예제](https://uchanlee.dev/static/256e8d7188dbba1d8c8d692079dd401a/0a47e/image-20.2.png)

그림 20.2 유스케이스 예제

- 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출 할지 명시하는 규칙을 담는다.
- 사용자 인터페이스를 기술하지 않는다.
  - 유스케이스만 봐선 이 애플리케이션이 웹인지 콘솔인지 등 구분할 수 없다.
- 유스케이스는 시스템이 사용자에게 어떻게 보이는지 설명하지 않는다.
  - 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 **사용자와 엔티티 사이의 상호작용**을 규정한다.

> 왜 엔티티는 고수준이고 유스케이스는 저수준일까?

- 유스케이스는 단일 애플리케이션에 특화되어 있어, 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문
- 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이므로, 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있음

###### 요청 및 응답 모델

유스케이스는 입력 데이터를 받아서 출력 데이터를 생성한다.

- 유스케이스 클래스의 코드가 HTML이나 SQL에 대해 알게하면 안된다.
- 의존성을 제거하는 일은 매우 중요하다.
- 요청 및 응답 모델이 독립적이어야 한다.
  - 그렇지 않다면, 그 모델에 의존하는 유스케이스가 모델과 간접적으로 결합되기 때문
- 엔티티 객체를 가리키는 참조를 요청 및 응답 데이터 구조에 포함해서는 안된다.
  - 두 객체의 목적이 완전히 다름

###### 결론

**업무 규칙은 소프트웨어 시스템이 존재하는 이유다.**

- 업무 규칙은 핵심적인 기능이다.
- 업무 규칙은 수익을 내고 비용을 줄이는 코드를 수반한다.

업무 규칙은 UI나 데이터베이스 같은 저수준의 관심사로 인해 오염되어서는 안되며, 원래 그대로 모습을 유지해야 한다.

- 업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인 되어야 한다.
- 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.